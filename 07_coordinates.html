<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Coordinates - learn-gfx-hal</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="02_opening_a_window.html"><strong aria-hidden="true">2.</strong> Opening A Window</a></li><li><a href="03_clear_the_window.html"><strong aria-hidden="true">3.</strong> Clear The Window</a></li><li><a href="04_triangle_intro.html"><strong aria-hidden="true">4.</strong> Triangle Intro</a></li><li><a href="05_shaders.html"><strong aria-hidden="true">5.</strong> Shaders</a></li><li><a href="06_textures.html"><strong aria-hidden="true">6.</strong> Textures</a></li><li><a href="07_coordinates.html" class="active"><strong aria-hidden="true">7.</strong> Coordinates</a></li><li><a href="08_camera.html"><strong aria-hidden="true">8.</strong> Camera</a></li><li><a href="09_depth_buffer.html"><strong aria-hidden="true">9.</strong> Depth Buffer</a></li><li><a href="10_instanced_drawing.html"><strong aria-hidden="true">10.</strong> Instanced Drawing</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">learn-gfx-hal</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#coordinates" id="coordinates"><h1>Coordinates</h1></a>
<p>So, when we did the Quad in the textures lesson, you may recall that it was
(x,y) for the base corner, and then width and height for the size, and then we
used the base corner plus the width and height to find the other three corners.
One of the non-base corners added the width to x, one added the height to y, and
one did both of the adds at the same time. How do we know that <code>x</code> and <code>width</code>
go together? Why doesn't <code>x</code> go with <code>height</code>? That's just kinda the convention
that you learn in school. <code>x</code> is horizontal with bigger values going to the
right, and <code>y</code> is vertical with bigger values going up. This is part of the
<a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system">Cartesian coordinate
system</a>. You might
not remember the name, but you probably remember the whole thing with <code>x</code> going
horizontally and <code>y</code> going vertically.</p>
<p>Here's the deal though. We're not aiming for just 2D drawing. We're aiming for
3D drawing and having 2D be just an occasional specialization of the whole 3D
process. So where does the <code>z</code> direction go? We probably drew that in our little
notebooks. It's hard to draw. On top of that we've got those <code>u</code> and <code>v</code> values
for texture lookups, and those don't have the origin in the middle of the space,
they have it in the top left corner of the texture. What's going on with any of
this nonsense?</p>
<a class="header" href="#coordinate-systems" id="coordinate-systems"><h2>Coordinate Systems</h2></a>
<p>Turns out there's not just one &quot;coordinate system&quot;, there's many coordinate
system<strong>s</strong>, that we have to deal with. Textures have a coordinate system, the
screen has a coordinate system, the scene has a coordinate system, and even each
individual model has a coordinate system. What?</p>
<p>Yeah, because floating point numbers have limited accuracy across big ranges,
the convention is to have all the points of a single model be in &quot;model space&quot;
with relatively small numbers and high accuracy. Then you have a transform
function that converts model space positions into world space positions based on
the overall position of the model in the world. Then the whole scene is being
viewed from some particular place and with a particular perspective, so there's
a transformation function to turn world space coordinates into screen space
coordinates. Any coordinate out of bounds of the screen space is off-screen, so
we don't even draw it.</p>
<a class="header" href="#transformations" id="transformations"><h2>Transformations</h2></a>
<p>So what's this &quot;function&quot; that shifts points between coordinate spaces? Well, I
kinda made it sound like a code function, but it's actually a math function
(<code>math</code>, <em>singular</em>, this is not a plural &quot;maths&quot; tutorial that's silly).</p>
<p>To translate a 3D point, we make the point into a <code>vec4</code> with the final position
as <code>1.0</code>, then we multiply it by a specially prepared 4x4 matrix (the
&quot;transformation matrix&quot;). That gives us a <code>vec4</code> output, and then to turn it
back into a <code>vec3</code> we just divide the <code>x</code>, <code>y</code>, and <code>z</code> axis by the <code>w</code> axis.</p>
<p>Vectors? Matrix? <code>w</code>-axis? What?</p>
<p>Ho boy are you in for some fun!</p>
<p>Yes, this (and more) is among the powers that math can grant you, but first you
must learn that math.</p>
<a class="header" href="#learning-the-math" id="learning-the-math"><h2>Learning The Math</h2></a>
<p>I'm not a math teacher, and math is universal enough that I can just tell you to
go learn from someone else's math course and you'll be able to use those skills
here, so that's exactly what I'll do.</p>
<ul>
<li>
<p>If you want <em>just</em> the fundamentals right now you can read the
<a href="https://learnopengl.com/Getting-started/Transformations">Transformations</a>
lesson on <code>LearnOpenGL.com</code>. Everything before the <code>In practice</code> section is
totally code free, just a math lesson, so you don't need to have any previous
OpenGL or C++ experience.</p>
</li>
<li>
<p>When you have the time you should really sit down and learn the subject a
little more properly there is a <a href="https://www.khanacademy.org/math/linear-algebra">Khan Academy Linear
Algebra</a> course, it's a totally
free video series style</p>
</li>
<li>
<p>If you like videos, the <a href="https://www.youtube.com/watch?v=fNk_zzaMoSs&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">Essence of Linear
Algebra</a>
by 3blue1brown is pretty amazing.</p>
</li>
</ul>
<a class="header" href="#applying-the-math" id="applying-the-math"><h2>Applying The Math</h2></a>
<p>So now that we know about how vectors and matrices work, how do we do this in
our code? Well, there's three main options here:</p>
<ul>
<li><a href="https://docs.rs/nalgebra-glm">nalgebra-glm</a> is a crate that provides a
GLM-like interface to the <a href="https://docs.rs/nalgebra">nalgebra</a> crate via type
aliases and such. <code>nalgebra</code> is a serious math crate for serious math people.
I generally wouldn't suggest that you use this crate <em>unless</em> you need to also
use the <code>ncollide</code> crate (which is a collision system based on nalgebra). The
extreme amount of generics makes error messages far worse when there's a type
error, and it also makes your compiles take longer.</li>
<li><a href="https://docs.rs/vek">vek</a> is the up and coming swiss army math lib that plans
to have an emphasis on SIMD support and is <code>#![no_std]</code>. I <em>always</em> approve of
a lib going for the <code>no_std</code> treatment. There's also a whole lot of features
you can enable to get extra benefits.</li>
<li><a href="https://docs.rs/cgmath">cgmath</a> is the &quot;tried and true beginner's crate&quot; for
graphics math. It's specifically their mandate to keep the focus on computer
graphics. Back in the day this set them apart from <code>nalgebra</code> all on its own,
but now that <code>vek</code> is coming up fast I'm not sure that <code>cgmath</code> has enough to
set itself apart.</li>
</ul>
<p>What should we use? Honestly, if it were just me I'd probably use <code>vek</code> to get
off the ground and then write my own vector math lib with no generics at all
when I wanted to take it easy during some programming day. Seriously, there's
only so much code involved in a vec math lib, you can totally write your own
from scratch.</p>
<p>However, this project isn't really about me, it's about you, the reader.
Accordingly, we're going to be using the <code>nalgebra-glm</code> crate. Out of all the
options, it's definitely got the worst error messages when things go wrong, so
any other crate that you decide to use instead will seem like a breeze in
comparison if you switch to another crate.</p>
<pre><code class="language-toml">[dependencies]
...
nalgebra-glm = &quot;0.2&quot;
</code></pre>
<a class="header" href="#the-primary-coordinate-systems" id="the-primary-coordinate-systems"><h1>The Primary Coordinate Systems</h1></a>
<p>There's actually an unlimited number of possible coordinate systems, but let's
focus on a few of them that you're most likely to encounter.</p>
<a class="header" href="#spatial-coordinates" id="spatial-coordinates"><h2>Spatial Coordinates</h2></a>
<p>A lot of the time we're concerned with 3D spatial positioning.</p>
<a class="header" href="#model-space" id="model-space"><h3>Model Space</h3></a>
<p>Each individual model exists in its own &quot;model space&quot;. A model can be anything
that's got all of its vertex positions specified in the same space. We'll be
using some basic shapes to start, and later on we'll learn how to load model
data out of a file.</p>
<p>The important thing about model space is that it's totally arbitrary and unique
to each model. You need to decide for yourself what your units are.</p>
<a class="header" href="#world-space" id="world-space"><h3>World Space</h3></a>
<p>By convention, each model within the scene has a transformation that converts
its model space points into world space points. This lets all of the models
exist in a single, unified coordinate space that's easier to think about.</p>
<p>As with model space, it's actually fairly arbitrary as to what your scale is.
The benefit of a world space is that you're usually doing not only the graphics,
but also any physics and such within the world space scale. It unifies the
whole simulation to get things into a space with a single origin.</p>
<a class="header" href="#view-space" id="view-space"><h3>View Space</h3></a>
<p>Graphics only happens from a particular point of observation. Transforming World
Space coordinates into how they should appear relative to the observer puts them
in &quot;View Space&quot;.</p>
<p>Once things are in View Space we can apply a Projection to the view. There's two
main projections to pick from:</p>
<ul>
<li>Orthographic Projection makes parallel lines stay parallel as they move far
away from you. Things are more angular, and even a little unreal looking
because of it. You probably want this projection for &quot;artificial&quot; sorts of
scenes, like if the user is designing something, or if the user is looking
over the scene in an &quot;all knowing&quot; sort of way and the scene is more like a
game board, like The Sims or Civilization.</li>
<li>Perspective Projection makes parallel lines appear to meet the farther away
they go from you. Like when looking far down a highway stretching out ahead.
This is basically how graphics work in the &quot;Real Life&quot; game, and that's a
fairly popular one that people have really become used to. You probably want
this projection if the scene is something that is being observed from some
sort of &quot;real&quot; perspective (either 1st person or 3rd person).</li>
</ul>
<p>The important thing here is that <em>the output is no longer arbitrary</em>. Once
you've run your projection matrix has transformed the vertex and the vertex
shader spits that value out, it has to be in what's called &quot;Normalized Device
Coordinates&quot;. For <code>gfx-hal</code> this means:</p>
<ul>
<li>X: -1.0 to +1.0 range, with +X going to the right</li>
<li>Y: -1.0 to +1.0 range, with +Y going to the down</li>
<li>Z: 0.0 to 1.0 range, with +Z going deeper into the screen</li>
</ul>
<a class="header" href="#texture-coordinates" id="texture-coordinates"><h2>Texture Coordinates</h2></a>
<p>In addition to &quot;physical&quot; locations, there's also texture lookups.</p>
<p>With textures the convention is to call the directions <code>u</code> and <code>v</code>, with <code>u</code>
being horizontal and <code>v</code> being vertical.</p>
<ul>
<li>U: 0.0 to 1.0, +U goes right</li>
<li>V: 0.0 to 1.0, +V goes down</li>
</ul>
<a class="header" href="#drawing-a-cube" id="drawing-a-cube"><h1>Drawing A Cube</h1></a>
<p>So, now that we've got a bit of an understanding of where our numbers need to
go, we just adjust the program a little bit. This time instead of doing a lot of
work in the fragment shader we're going to have the biggest change with the
fragment shader.</p>
<a class="header" href="#the-draw-call" id="the-draw-call"><h2>The Draw Call</h2></a>
<p>Okay so we're gonna draw one cube. In fact, now that we can put things in
different places and have it all show up properly, we'll draw <em>many</em> cubes. What
will define our cubes? Not vertex data any more. We're done with that. Now there
will be a <em>single</em> set of cube vertex data. Instead, a particular cube will be
defined by a model matrix to translate the local model points into world space
points. So drawing a series of cubes means we accept a slice of models and then
loop over each one.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn draw_cubes_frame(&amp;mut self, models: &amp;[glm::TMat4&lt;f32&gt;]) -&gt; Result&lt;(), &amp;'static str&gt; {
#}</code></pre></pre>
<p>The setup with picking our fences and such is the same as before, but then we
get to the new stuff. We need to get a Model-View-Projection Matrix to convert
the iconic cube data into a particular cube on the screen. We'll be drawing
several cubes, but they'll each have the same View and Projection Matrix, so
we'll determine View and Projection first.</p>
<a class="header" href="#view-matrix" id="view-matrix"><h3>View Matrix</h3></a>
<p>The View Matrix turns World Space into &quot;Camera Space&quot;. For our View matrix, we
want to use
<a href="https://docs.rs/nalgebra-glm/0.2.1/nalgebra_glm/fn.look_at_lh.html">look_at_lh</a>.
It's &quot;look at, left-handed&quot;. You can also have &quot;right-handed&quot; coordinate systems
(it has to do with which direction is positive as you move along each axis), but
<code>gfx-hal</code> is a left-handed coordinate system. Any time <code>nalgebra_glm</code> lets you
pick between the two you should pick the left-handed variant.</p>
<ul>
<li>The first argument is <em>where the camera is</em>.</li>
<li>The second argument is <em>where the camera is looking</em></li>
<li>The final argument is a <strong>normalized</strong> vector for which way is &quot;up&quot;. The third
argument can generally default to <code>[0.0, 1.0, 0.0]</code>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // DETERMINE VIEW MATRIX (just once)
    let view = glm::look_at_lh(
      &amp;glm::make_vec3(&amp;[0.0, 0.0, -5.0]),
      &amp;glm::make_vec3(&amp;[0.0, 0.0, 0.0]),
      &amp;glm::make_vec3(&amp;[0.0, 1.0, 0.0]).normalize(),
    );
#}</code></pre></pre>
<p>Remember that +Z is &quot;into the screen&quot;, so we'll be starting a little &quot;back&quot; from
the world origin, looking at the world origin, and with the default up vector.</p>
<a class="header" href="#projection-matrix" id="projection-matrix"><h3>Projection Matrix</h3></a>
<p>The Projection Matrix turns Camera Space into &quot;Normalized Device Coordinates&quot;
(NDC). We start with a perspective matrix, but instead of just <code>perspective_lh</code>,
we need to add another detail. The whole GLM API was setup for OpenGL, which
uses -1.0 to +1.0 for Z, but <code>gfx-hal</code> uses only 0.0 to 1.0 for Z. As a result,
we need to select both the &quot;left-handed&quot;, and also <code>_zo</code> variant of the
perspective function, giving us
<a href="https://docs.rs/nalgebra-glm/0.2.1/nalgebra_glm/fn.perspective_lh_zo.html">perspective_lh_zo</a>.</p>
<ul>
<li>The first argument is the aspect ratio of the display area. We just put our width / height and we're set.</li>
<li>The second argument is the <a href="https://en.wikipedia.org/wiki/Field_of_view_in_video_games">field of
view</a> angle (in
radians). This is something that you should probably let your users customize
if you're making a &quot;real&quot; program. A comfortable field of view depends on the
user's physical screen size and how close they're sitting to it.</li>
<li>The third and fourth arguments are the distance to the near and far clipping
plane.</li>
</ul>
<p>Now once we have our Perspective calculation given to us, we need to flip the Y
value. This makes it so that increasing Y values in World Space will cause a
<em>decrease</em> in the Y result within NDC space. That way when things move up in the
world they actually go up on the screen too. Flipping all the Y values might
sound tricky, but we just need to negate a single element in the matrix,
position <code>(1,1)</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // DETERMINE PROJECTION MATRIX (just once)
    let projection = {
      let mut temp = glm::perspective_lh_zo(800.0 / 600.0, f32::to_radians(50.0), 0.1, 100.0);
      temp[(1, 1)] *= -1.0;
      temp
    };
#}</code></pre></pre>
<p>Now, yes, I know that maybe technically we shouldn't hard code the aspect ratio,
since we went to all that trouble to make our window resizable and everything,
but it's fine. Consider that small detail to be homework for the dedicated
reader.</p>
<a class="header" href="#a-combined-view-projection-matrix" id="a-combined-view-projection-matrix"><h3>A Combined View-Projection Matrix</h3></a>
<p>A matrix multiplication is actually fairly costly. For a 4x4 matrix you're doing
16 dot products. We want to keep that down, so we'll calculate a single
&quot;view-projection&quot; matrix right now (since it doesn't change per model), and then
use it for each model that we draw.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    // COMBINE THE VIEW AND PROJECTION MATRIX AHEAD OF TIME (just once)
    let vp = projection * view;
#}</code></pre></pre>
<p>Remember, the right side of a stack of matrix transforms is the side that
happens &quot;first&quot; within the total transformation. Since we want to go from Model
Space to World Space to View Space to NDC Space, we'll have the model on the far
right, then the view in the middle, then the projection on the left side. Since
this doesn't have the model data yet, it's just projection on the left times the
view.</p>
<a class="header" href="#drawing-those-models" id="drawing-those-models"><h3>Drawing Those Models</h3></a>
<p>Now that we're all set we bind the various pipeline stuff like before. This
time, instead of writing the push constants once and then calling draw once, we
do a loop over all the models. For each model we compute the final MVP matrix by
going <code>vp * model</code>, push that, and then do a draw call.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
        // ONE DRAW CALL PER MODEL MATRIX WE'RE GIVEN
        for model in models.iter() {
          // DETERMINE FINAL MVP MATRIX (once per model)
          let mvp = vp * model;
          encoder.push_graphics_constants(
            &amp;self.pipeline_layout,
            ShaderStageFlags::VERTEX,
            0,
            cast_slice::&lt;f32, u32&gt;(&amp;mvp.data)
              .expect(&quot;this cast never fails for same-aligned same-size data&quot;),
          );
          encoder.draw_indexed(0..36, 0, 0..1);
        }
#}</code></pre></pre>
<p>That's it! We've got cubes!</p>
<p>Well, no, not yet, we have to setup the rest of the pipeline to support our new
draw method, but we're well on the way to cubes.</p>
<a class="header" href="#new-buffer-data" id="new-buffer-data"><h1>New Buffer Data</h1></a>
<p>Let's put that cube data in our buffers!</p>
<a class="header" href="#defining-a-vertex-type" id="defining-a-vertex-type"><h2>Defining A <code>Vertex</code> Type</h2></a>
<p>As promised, we'll finally define a type for the Vertex format.</p>
<p>First, it must be <code>repr(C)</code>. Second, we'll give it a static function to spit out
the appropriate <code>Vec&lt;AttributeDesc&gt;</code> for the type. That way the two definitions
sit as close as possible in the code and we're more likely to change both at the
same time if one of them has a change.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Clone, Copy)]
#[repr(C)]
pub struct Vertex {
  xyz: [f32; 3],
  uv: [f32; 2],
}
impl Vertex {
  pub fn attributes() -&gt; Vec&lt;AttributeDesc&gt; {
    let position_attribute = AttributeDesc {
      location: 0,
      binding: 0,
      element: Element {
        format: Format::Rgb32Float,
        offset: 0,
      },
    };
    let uv_attribute = AttributeDesc {
      location: 1,
      binding: 0,
      element: Element {
        format: Format::Rg32Float,
        offset: size_of::&lt;[f32; 3]&gt;() as ElemOffset,
      },
    };
    vec![position_attribute, uv_attribute]
  }
}
#}</code></pre></pre>
<a class="header" href="#define-the-cube-vertexes" id="define-the-cube-vertexes"><h2>Define The Cube Vertexes</h2></a>
<p>Now at the minimum a cube needs 8 points. However, to make the textures show up
properly we'll need to have 6 quads so that the triangles can wind properly.
This means that we'll need 24 vertexes. Unfortunate.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg_attr(rustfmt, rustfmt_skip)]
const CUBE_VERTEXES: [Vertex; 24] = [
  // Face 1 (front)
  Vertex { xyz: [0.0, 0.0, 0.0], uv: [0.0, 1.0] }, /* bottom left */
  Vertex { xyz: [0.0, 1.0, 0.0], uv: [0.0, 0.0] }, /* top left */
  Vertex { xyz: [1.0, 0.0, 0.0], uv: [1.0, 1.0] }, /* bottom right */
  Vertex { xyz: [1.0, 1.0, 0.0], uv: [1.0, 0.0] }, /* top right */
  // Face 2 (top)
  Vertex { xyz: [0.0, 1.0, 0.0], uv: [0.0, 1.0] }, /* bottom left */
  Vertex { xyz: [0.0, 1.0, 1.0], uv: [0.0, 0.0] }, /* top left */
  Vertex { xyz: [1.0, 1.0, 0.0], uv: [1.0, 1.0] }, /* bottom right */
  Vertex { xyz: [1.0, 1.0, 1.0], uv: [1.0, 0.0] }, /* top right */
  // Face 3 (back)
  Vertex { xyz: [0.0, 0.0, 1.0], uv: [0.0, 1.0] }, /* bottom left */
  Vertex { xyz: [0.0, 1.0, 1.0], uv: [0.0, 0.0] }, /* top left */
  Vertex { xyz: [1.0, 0.0, 1.0], uv: [1.0, 1.0] }, /* bottom right */
  Vertex { xyz: [1.0, 1.0, 1.0], uv: [1.0, 0.0] }, /* top right */
  // Face 4 (bottom)
  Vertex { xyz: [0.0, 0.0, 0.0], uv: [0.0, 1.0] }, /* bottom left */
  Vertex { xyz: [0.0, 0.0, 1.0], uv: [0.0, 0.0] }, /* top left */
  Vertex { xyz: [1.0, 0.0, 0.0], uv: [1.0, 1.0] }, /* bottom right */
  Vertex { xyz: [1.0, 0.0, 1.0], uv: [1.0, 0.0] }, /* top right */
  // Face 5 (left)
  Vertex { xyz: [0.0, 0.0, 1.0], uv: [0.0, 1.0] }, /* bottom left */
  Vertex { xyz: [0.0, 1.0, 1.0], uv: [0.0, 0.0] }, /* top left */
  Vertex { xyz: [0.0, 0.0, 0.0], uv: [1.0, 1.0] }, /* bottom right */
  Vertex { xyz: [0.0, 1.0, 0.0], uv: [1.0, 0.0] }, /* top right */
  // Face 6 (right)
  Vertex { xyz: [1.0, 0.0, 0.0], uv: [0.0, 1.0] }, /* bottom left */
  Vertex { xyz: [1.0, 1.0, 0.0], uv: [0.0, 0.0] }, /* top left */
  Vertex { xyz: [1.0, 0.0, 1.0], uv: [1.0, 1.0] }, /* bottom right */
  Vertex { xyz: [1.0, 1.0, 1.0], uv: [1.0, 0.0] }, /* top right */
];
#}</code></pre></pre>
<a class="header" href="#define-the-cube-indexes" id="define-the-cube-indexes"><h2>Define The Cube Indexes</h2></a>
<p>Of course, we need some indexes to go with the vertexes. We have to be very
careful here because if you get the winding on your triangles wrong things look
very bad very fast.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg_attr(rustfmt, rustfmt_skip)]
const CUBE_INDEXES: [u16; 36] = [
   0,  1,  2,  2,  1,  3, // front
   4,  5,  6,  7,  6,  5, // top
  10,  9,  8,  9, 10, 11, // back
  12, 14, 13, 15, 13, 14, // bottom
  16, 17, 18, 19, 18, 17, // left
  20, 21, 22, 23, 22, 21, // right
];
#}</code></pre></pre>
<a class="header" href="#other-stuff" id="other-stuff"><h2>Other Stuff</h2></a>
<p>At this point you can figure out the rest yourself, and you can look at the
final code if there's a bit you're missing, but basically we want to fix up
<code>HalState</code> to have a field for the cube vertex buffer and the cube index buffer.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
  cube_vertices: BufferBundle&lt;back::Backend, back::Device&gt;,
  cube_indexes: BufferBundle&lt;back::Backend, back::Device&gt;,
#}</code></pre></pre>
<p>And then you want to fill those up just once during initialization.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let cube_vertices = BufferBundle::new(
      &amp;adapter,
      &amp;device,
      size_of_val(&amp;CUBE_VERTEXES),
      BufferUsage::VERTEX,
    )?;

    // Write the vertex data just once.
    unsafe {
      let mut data_target = device
        .acquire_mapping_writer(&amp;cube_vertices.memory, 0..cube_vertices.requirements.size)
        .map_err(|_| &quot;Failed to acquire an index buffer mapping writer!&quot;)?;
      data_target[..CUBE_VERTEXES.len()].copy_from_slice(&amp;CUBE_VERTEXES);
      device
        .release_mapping_writer(data_target)
        .map_err(|_| &quot;Couldn't release the index buffer mapping writer!&quot;)?;
    }

    let cube_indexes = BufferBundle::new(
      &amp;adapter,
      &amp;device,
      size_of_val(&amp;CUBE_INDEXES),
      BufferUsage::INDEX,
    )?;

    // Write the index data just once.
    unsafe {
      let mut data_target = device
        .acquire_mapping_writer(&amp;cube_indexes.memory, 0..cube_indexes.requirements.size)
        .map_err(|_| &quot;Failed to acquire an index buffer mapping writer!&quot;)?;
      data_target[..CUBE_INDEXES.len()].copy_from_slice(&amp;CUBE_INDEXES);
      device
        .release_mapping_writer(data_target)
        .map_err(|_| &quot;Couldn't release the index buffer mapping writer!&quot;)?;
    }
#}</code></pre></pre>
<p>In the graphics pipeline we need to change the rasterizer so that the back faces
of each triangle are culled. Without the culling, you'll get a bizarre looking
thing where the insides and the outsides of the cubes are drawn at the same
time. Like something Escher might draw.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
      let rasterizer = Rasterizer {
        depth_clamping: false,
        polygon_mode: PolygonMode::Fill,
        cull_face: Face::BACK,
        front_face: FrontFace::Clockwise,
        depth_bias: None,
        conservative: false,
      };
#}</code></pre></pre>
<p>Finally we need to change up the push_constants to be 16 floats in the Vertex
shader instead of 1 float in the fragment shader:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
      let push_constants = vec![(ShaderStageFlags::VERTEX, 0..16)];
#}</code></pre></pre>
<a class="header" href="#new-shaders" id="new-shaders"><h1>New Shaders</h1></a>
<p>Of course we'll need our GLSL to use the new data properly too.</p>
<a class="header" href="#vertex-shader" id="vertex-shader"><h2>Vertex Shader</h2></a>
<p>This is the &quot;interesting&quot; part, by which I mean that it's where the coordinate
spaces all meet up and shift around. However, it's not very interesting code to
just look at, since it boils down to basically one expression.</p>
<p>I said above that the &quot;right most&quot; part of a matrix transform stack happens
&quot;first&quot;, but what's it happening to? The data vector at the very far right of
the whole final equation of course. As I glibly said at the start of the
article, we take our 3D coordinate, add a <code>w</code> component of 1.0, and then
multiply it through our big matrix stack. Whatever comes out the left side is
the NDC of the position.</p>
<pre><code class="language-glsl">#version 450
layout (push_constant) uniform PushConsts {
  mat4 mvp;
} push;

layout (location = 0) in vec3 position;
layout (location = 1) in vec2 vert_uv;

layout (location = 0) out gl_PerVertex {
  vec4 gl_Position;
};
layout (location = 1) out vec2 frag_uv;

void main()
{
  gl_Position = push.mvp * vec4(position, 1.0);
  frag_uv = vert_uv;
}
</code></pre>
<a class="header" href="#fragment-shader" id="fragment-shader"><h2>Fragment Shader</h2></a>
<p>The fragment shader this time is simplified from last time. We don't need any
color shifting or anything at this point, just having some boxes should be
interesting enough to look at.</p>
<pre><code class="language-glsl">#version 450
layout(set = 0, binding = 0) uniform texture2D tex;
layout(set = 0, binding = 1) uniform sampler samp;

layout (location = 1) in vec2 frag_uv;

layout (location = 0) out vec4 color;

void main()
{
  color = texture(sampler2D(tex, samp), frag_uv);
}
</code></pre>
<a class="header" href="#update-the-main-functionality" id="update-the-main-functionality"><h1>Update The <code>main</code> Functionality</h1></a>
<p>So our <code>do_the_render</code> function simplifies down to just one line:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn do_the_render(hal_state: &amp;mut HalState, local_state: &amp;LocalState) -&gt; Result&lt;(), &amp;'static str&gt; {
  hal_state.draw_cubes_frame(&amp;local_state.cubes)
}
#}</code></pre></pre>
<a class="header" href="#time-per-frame" id="time-per-frame"><h2>Time Per Frame</h2></a>
<p>Last lesson we just tracked the time since the program started. That's fine if
your animation follows a perfect and immutable pattern (like sine wave shifting
between two modes), but most things aren't like that. Most of the time we want
to know the amount of time per frame so that we can apply that much time towards
an animation that might or might not be happening.</p>
<p>So we'll start tracking a time per frame. This will be a very basic &quot;Semi-fixed
Time Step&quot; scheme (there's an <a href="https://gafferongames.com/post/fix_your_timestep/">article all about
it</a>). Basically, each time
through the loop we'll accumulate some time. If there's enough time accumulated
we'll advance the &quot;state&quot; of our program (in our case we rotate the cubes some).</p>
<a class="header" href="#userinput" id="userinput"><h3>UserInput</h3></a>
<p>First we have to adjust the <code>UserInput</code> type so that the time taken is part of
the input for the frame. It could go just about anywhere as long as we check the
time once per frame, but if we consider the timing to be part of the input then
at some future point we could just start recording inputs and then playing them
back and they'll play back with the right associated timings. Bam, we've got
looped replay for practically nothing.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Clone, Default)]
pub struct UserInput {
  pub end_requested: bool,
  pub new_frame_size: Option&lt;(f64, f64)&gt;,
  pub new_mouse_position: Option&lt;(f64, f64)&gt;,
  pub seconds: f32,
}
#}</code></pre></pre>
<p>Now when we make a <code>UserInput</code> value we'll also take the timestamp from the last frame:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
  pub fn poll_events_loop(events_loop: &amp;mut EventsLoop, last_timestamp: &amp;mut Instant) -&gt; Self {
#}</code></pre></pre>
<p>And after the call to <code>poll_events</code> we also set the <code>seconds</code> field.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    output.seconds = {
      let now = Instant::now();
      let duration = now.duration_since(*last_timestamp);
      *last_timestamp = now;
      duration.as_secs() as f32 + duration.subsec_nanos() as f32 * 1e-9
    };
#}</code></pre></pre>
<a class="header" href="#localstate" id="localstate"><h3>LocalState</h3></a>
<p>Now we update <code>LocalState</code> to track the spare time we had from last time:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Clone, Default)]
pub struct LocalState {
  pub frame_width: f64,
  pub frame_height: f64,
  pub mouse_x: f64,
  pub mouse_y: f64,
  pub cubes: Vec&lt;glm::TMat4&lt;f32&gt;&gt;,
  pub spare_time: f32,
}
#}</code></pre></pre>
<p>And every frame when we update, we'll use 1/60th of a second of time if it's
available. This makes the physics work as smoothly as possible. Of course, in a
full program you'd need some more checks before you blindly perform however many
physics frames all at once. If the system clock goes backwards maybe skip doing
physics that frame. If the system clock jumps forward too many frames at once
maybe cap out at some handful and discard the rest. And ideally you'd need to
make sure that your computation time per frame is <em>on average</em> less than the
actual time otherwise your leftover time would grow forever and the system would
chug slower and slower. Time has a lot of fiddly bits to get right if you want
to be robust about it.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl LocalState {
  pub fn update_from_input(&amp;mut self, input: UserInput) {
    if let Some(frame_size) = input.new_frame_size {
      self.frame_width = frame_size.0;
      self.frame_height = frame_size.1;
    }
    if let Some(position) = input.new_mouse_position {
      self.mouse_x = position.0;
      self.mouse_y = position.1;
    }
    assert!(self.frame_width != 0.0 &amp;&amp; self.frame_height != 0.0);
    let x_axis = (self.mouse_x / self.frame_width) as f32;
    let y_axis = (self.mouse_y / self.frame_height) as f32;
    self.spare_time += input.seconds;
    const ONE_SIXTIETH: f32 = 1.0 / 60.0;
    while self.spare_time &gt; 0.0 {
      for (i, cube_mut) in self.cubes.iter_mut().enumerate() {
        let r = ONE_SIXTIETH * 30.0 * (i as f32 + 1.0);
        *cube_mut = glm::rotate(
          &amp;cube_mut,
          f32::to_radians(r),
          // if you change z to 0.0 you need to assert that x_axis and y_axis
          // don't also end up as 0.0, otherwise you'll get NaN when you
          // normalize and then you'll get NaN in your matrix and then nothing
          // will display.
          &amp;glm::make_vec3(&amp;[x_axis, y_axis, 0.3]).normalize(),
        );
      }
      self.spare_time -= ONE_SIXTIETH;
    }
  }
}
#}</code></pre></pre>
<p>As to the actual &quot;physics&quot; we're doing, we'll just rotate the cubes some. Since
I still want a little interaction, so we'll have the mouse position control the
angle of rotation.</p>
<p>And now we got spinny boxes!</p>
<p><img src="images/coordinates-complete.png" alt="coordinates-complete" /></p>
<p>As always, full code is available in the <a href="https://github.com/Lokathor/learn-gfx-hal/tree/master/examples">examples directory</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="06_textures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="08_camera.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="06_textures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="08_camera.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
